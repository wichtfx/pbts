#!/usr/bin/env python3
"""
Torrent File Generator for PBTS Testing

Creates .torrent files for testing with PBTS tracker.
"""

import hashlib
import argparse
from pathlib import Path
from typing import Optional

try:
    import bencoder
except ImportError:
    print("ERROR: bencoder module required. Install with: pip install bencoder.pyx")
    exit(1)


def generate_test_data(size_bytes: int, output_path: Path):
    """
    Generate deterministic test data file

    Args:
        size_bytes: Size of file to generate
        output_path: Where to write the file
    """
    print(f"Generating test data file ({size_bytes} bytes)...")

    # Generate deterministic data
    data = b"PBTS Test Data - " + b"X" * (size_bytes - 17)

    with open(output_path, 'wb') as f:
        f.write(data)

    print(f"  ✓ Created: {output_path}")
    return data


def create_torrent(
    data_file: Path,
    tracker_url: str,
    output_path: Path,
    piece_length: int = 16384,
    private: bool = True,
    name: Optional[str] = None
):
    """
    Create a .torrent file

    Args:
        data_file: Path to file to create torrent for
        tracker_url: Tracker announce URL
        output_path: Where to write .torrent file
        piece_length: Bytes per piece (default 16KB)
        private: Mark as private tracker (default True)
        name: Optional name (defaults to filename)

    Returns:
        Info hash (hex string)
    """
    print(f"\nCreating torrent for: {data_file}")
    print(f"  Tracker: {tracker_url}")
    print(f"  Piece length: {piece_length} bytes")

    # Read file data
    with open(data_file, 'rb') as f:
        data = f.read()

    file_length = len(data)
    print(f"  File size: {file_length} bytes")

    # Calculate pieces
    pieces = []
    for i in range(0, file_length, piece_length):
        piece = data[i:i + piece_length]
        piece_hash = hashlib.sha1(piece).digest()
        pieces.append(piece_hash)

    num_pieces = len(pieces)
    print(f"  Number of pieces: {num_pieces}")

    # Build info dictionary
    info = {
        b'name': (name or data_file.name).encode('utf-8'),
        b'piece length': piece_length,
        b'pieces': b''.join(pieces),
        b'length': file_length,
    }

    if private:
        info[b'private'] = 1

    # Calculate info hash
    info_bencoded = bencoder.encode(info)
    infohash = hashlib.sha1(info_bencoded).digest()
    infohash_hex = infohash.hex()

    print(f"  Info hash: {infohash_hex}")

    # Build torrent dictionary
    torrent = {
        b'announce': tracker_url.encode('utf-8'),
        b'info': info,
        b'comment': b'Generated by PBTS torrent_generator.py',
        b'creation date': 1700000000,  # Fixed timestamp for determinism
        b'created by': b'PBTS/0.1.0'
    }

    # Write torrent file
    with open(output_path, 'wb') as f:
        f.write(bencoder.encode(torrent))

    print(f"  ✓ Created: {output_path}")

    return infohash_hex


def parse_torrent(torrent_path: Path):
    """
    Parse and display torrent file information

    Args:
        torrent_path: Path to .torrent file
    """
    print(f"\nParsing torrent: {torrent_path}")

    with open(torrent_path, 'rb') as f:
        torrent = bencoder.decode(f.read())

    # Extract info
    announce = torrent[b'announce'].decode('utf-8')
    info = torrent[b'info']

    name = info[b'name'].decode('utf-8')
    piece_length = info[b'piece length']
    length = info[b'length']
    pieces_data = info[b'pieces']
    num_pieces = len(pieces_data) // 20
    is_private = info.get(b'private', 0) == 1

    # Calculate info hash
    infohash = hashlib.sha1(bencoder.encode(info)).digest()

    print(f"\n  Name: {name}")
    print(f"  Announce: {announce}")
    print(f"  Info hash: {infohash.hex()}")
    print(f"  Size: {length} bytes")
    print(f"  Piece length: {piece_length} bytes")
    print(f"  Number of pieces: {num_pieces}")
    print(f"  Private: {is_private}")

    return infohash.hex()


def main():
    parser = argparse.ArgumentParser(
        description='Generate .torrent files for PBTS testing',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Generate test data and create torrent
  %(prog)s --generate 1048576 --output test.torrent

  # Create torrent from existing file
  %(prog)s --file myfile.dat --output myfile.torrent

  # Parse existing torrent
  %(prog)s --parse test.torrent
        """
    )

    parser.add_argument(
        '--generate',
        type=int,
        metavar='SIZE',
        help='Generate test data file of SIZE bytes'
    )
    parser.add_argument(
        '--file',
        type=Path,
        help='Create torrent from existing file'
    )
    parser.add_argument(
        '--output',
        type=Path,
        help='Output .torrent file path'
    )
    parser.add_argument(
        '--tracker',
        default='http://localhost:8000/announce',
        help='Tracker announce URL (default: http://localhost:8000/announce)'
    )
    parser.add_argument(
        '--piece-length',
        type=int,
        default=16384,
        help='Piece length in bytes (default: 16384)'
    )
    parser.add_argument(
        '--name',
        help='Name for torrent (defaults to filename)'
    )
    parser.add_argument(
        '--parse',
        type=Path,
        help='Parse and display torrent file info'
    )

    args = parser.parse_args()

    # Parse mode
    if args.parse:
        parse_torrent(args.parse)
        return

    # Generate or use existing file
    if args.generate:
        if not args.output:
            print("ERROR: --output required when using --generate")
            return

        # Generate test data file
        data_file = args.output.with_suffix('.dat')
        generate_test_data(args.generate, data_file)

    elif args.file:
        if not args.file.exists():
            print(f"ERROR: File not found: {args.file}")
            return
        data_file = args.file

    else:
        parser.print_help()
        return

    # Create torrent
    if not args.output:
        args.output = data_file.with_suffix('.torrent')

    infohash = create_torrent(
        data_file=data_file,
        tracker_url=args.tracker,
        output_path=args.output,
        piece_length=args.piece_length,
        name=args.name
    )

    print(f"\n✅ Torrent created successfully!")
    print(f"\nTo use with PBTS client:")
    print(f"  python tests/pbts_client.py --torrent {args.output} --mode seeder --data {data_file}")


if __name__ == "__main__":
    main()
